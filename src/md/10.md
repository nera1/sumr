---
filename: 10.md
tags:
  - spring
  - springboot
  - jmeter
  - postgresql
  - trgm
  - pg_trgm
  - pgroonga
category: postgresql
created: Mon, 11 Aug 2025 10:19:04 GMT
title: PostgreSQL Index, Extension
---

## Index

MySQL과 마찬가지로 PostgreSQL 13에서 디폴트 인덱스로 B-Tree를 사용하고 있습니다

> PostgreSQL provides several index types: B-tree, Hash, GiST, SP-GiST, GIN, BRIN, and the extension bloom. Each index type uses a different algorithm that is best suited to different types of indexable clauses. By default, the CREATE INDEX command creates B-tree indexes, which fit the most common situations.
> [PostgreSQL 공식 문서](https://www.postgresql.org/docs/13/indexes-types.html)

- B-Tree 는 값의 대소비교를 통해 노드를 구성합니다
- PostgreSQL은 `Collation(컬레이션)`이라는 내부 정렬 규칙에 따라 문자열을 정렬합니다
  - PostgreSQL은 문자열 비교 세부 알고리즘을 공식 문서에 기술하지 않았습니다
  - C / POSIX, libc, ICU 등의 `Collation` 공급자가 있으나 각 공급자에서 정렬 시 사용되는 함수가 모두 사전식으로 문자 왼쪽부터 오른쪽으로 비교가 진행됩니다
- `LIKE 'abc%'` 처럼 왼쪽부터 고정된 접두가 있으면, 인덱스에서 'abc' 시작 지점을 찾아 그 이후의 연속된 구간만 읽으면 됩니다.
  - 하지만 `LIKE '%abc'`나 `LIKE '%abc%'`는 첫 글자가 무엇인지 모르는 조건이어서, 인덱스 정렬 순서상 흩어져 있는 모든 후보를 찾아야 합니다.
  - PostgreSQL은 이 경우 인덱스를 범위 스캔으로 사용할 수 없습니다

## GIN Index (Generalized Inverted Index)

- 문자열, 또는 문서에서 여러 `Key(단어, 문자열 등)`을 뽑아 `Key`별로 등장 행 목록을 저장하는 역색인 입니다
- `Key : Posting List` 쌍들의 집합이며, 내부적으로 `Key` 정렬을 위한 B-Tree가 존재합니다
- GIN Index의 동작방식은 간단히 아래와 같습니다

```bash
1. Where is my mind
2. All you need is love
3. Dont forget my love
```

위 세문장을 단어 단위(Key)로 나누고, 단어마다 문장의 ID 리스트를 매깁니다

```bash
Where : [1]
is : [1,2]
my : [1,3]
mind : [1]
All : [2]
you : [2]
need : [2]
love : [2,3]
Dont : [3]
forget : [3]
```

위와 같은 GIN Index가 완성되면 **love**라는 단어가 2,3번 문장에 있음을 쉽게 파악할 수 있습니다

## pg_trgm

- 문자열을 3글자 조각(trigram)으로 분해해 유사도 계산과 부분검색 가속에 사용합니다
- 트라이그램 추출 규칙: 비-단어 문자(영숫자 이외)는 무시, 각 **단어**는 앞에 공백 2개, 뒤에 공백 1개를 패딩해 트라이그램을 뽑습니다(예: "cat" → " c", " ca", "cat", "at ")
- 인덱스 지원: pg_trgm은 GiST/GIN 연산자 클래스를 제공하며, LIKE/ILIKE/정규식(~,~\*) 그리고 = 까지 trigram 기반 인덱스 검색을 지원합니다

#### 왜 trigram 으로 분해하는가?

1. 경험적 절충점
   1. 1~2글자 : 후보가 너무 많아 선택도가 낮다
   2. 3글자 : 짧은 단어도 어느 정도 구분이 가능하다, 인덱스 크기·선택도 균형이 좋다
   3. 4글자 이상: 선택도는 높아지지만, 짧은 단어 검색이 힘들어진다
2. ASCII, 유니코드(한글 포함), 여러 언어에서도 잘 동작
3. trigram이 GIN Index에 적합

```sql
-- pg_trgm 설치
CREATE EXTENSION IF NOT EXISTS pg_trgm;
-- GIN Index 생성, gin_trgm_ops 옵션
CREATE INDEX IF NOT EXISTS idx_channel_name_trgm
  ON channels USING gin (name gin_trgm_ops);
-- ANALYZE는 테이블 내용 통계를 **pg_statistic**에 수집/갱신하고, 플래너가 인덱스 사용 여부를 더 정확히 판단
ANALYZE channels;
```

위 SQL을 실행하여 `pg_trgm + GIN Index`를 생성 후 지난 포스트와 같은 테스트를 실행합니다

[LIKE 검색 테스트](/post/9)

<p style="display:flex;justify-content:center">
  <img src="../../images/9/4.png" width="100%" alt="image"/>
</p>

- 위 결과는 `name` column 에 B-Tree 인덱스만 설정했을 때 결과입니다

<p style="display:flex;justify-content:center">
  <img src="../../images/10/1.png" width="100%" alt="image"/>
</p>

- 위 결과는 `name` column 에 대해 `pg_trgm + GIN Index`가 적용되었을 때 결과입니다
- 응답시간의 상한선이 일정해지고, 눈에띄게 감소하였음을 알 수 있습니다

## PGroonga

- Groonga라는 오픈소스 풀텍스트 검색 엔진을 PostgreSQL Extension으로 통합하였습니다
- 단순 부분검색뿐 아니라 형태소 분석, 랭킹, 하이라이팅, 다국어 검색등을 지원합니다

```sql
CREATE EXTENSION IF NOT EXISTS pgroonga;

CREATE INDEX idx_channel_name_norm_pgroonga
  ON channels USING pgroonga(
    REPLACE(LOWER(name), ' ', '')
  );
ANALYZE channels;
```

- 위 쿼리처럼 스트링 내부 공백을 다 지우고 인덱스 생성 시, PGroonga의 형태소 분석 기능이 무의미해집니다
  - 공백을 지우지 않고 형태소 분석을 위한 `TokenMecab` tokenizer 와, `NormalizerNFKC100` normalizer등을 적용한 인덱스를 생성하고 검색해 보았으나 `중학생` 검색시 `중학` + `생`을 분리하여 `중학교` 등을 검색하는 데 실패하는 등 형태소 검색에 실패하였습니다
- `PGroonga`는 `pg_trgm + GIN Index` 조합처럼 생성된 인덱스에 함수 `REPLACE(), LOWER()`등을 적용할수 없어 인덱스 생성시에 미리 함수를 적용해야 합니다

<p style="display:flex;justify-content:center">
  <img src="../../images/10/2.png" width="100%" alt="image"/>
</p>

- `PGroonga` 및 `pg_trgm + GIN Index` 까지 합친 결과입니다 응답시간이 더 줄어들게 되었습니다

## 마무리

> PGroonga, pg_trgm + GIN Index 등의 Extension과 인덱스를 모두 적용하면, 읽기 작업에 대한 응답시간이 크게 줄어드는것을 확인했습니다.  
> 하지만 인덱스의 크기가 늘어 쓰기 속도가 늘어나고, 형태소 분석을 할 수 없는 경우 PGroonga의 사용 의미가 많이 퇴색됩니다.  
> 간단한 LIKE 부분검색의 경우 두 Extension중 적절한 것을 선택할 필요가 있어보입니다