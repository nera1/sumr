---
filename: 9.md
tags:
  - spring
  - springboot
  - jmeter
category: jmeter
created: Sun, 10 Aug 2025 15:01:25 GMT
title: LIKE 검색 테스트
---

## 채널 검색 기능

<p style="display:flex;justify-content:center">
  <img src="../../images/9/1.png" width="45%" alt="image"/>
</p>

- 채팅 제목을 검색하는 서비스를 제공하고 있습니다
- 전문검색, 장문의 스트링을 검색하는 경우에는 Elasticsearch를 고려해야 합니다
- 비교적 짧고 단순한 스트링을 검색하기에 `LIKE` 검색을 사용하고 있습니다

### LIKE 검색

```java title="Channel.java"
package com.api.backend.domain;

import java.time.LocalDateTime;

import org.hibernate.annotations.CreationTimestamp;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "channels")
@Getter
@Setter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
public class Channel {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "public_id", nullable = false, unique = true, updatable = false, length = 36)
    private String publicId;

    @Column(nullable = false)
    private String name;

    @Column(name = "creator_id", nullable = false)
    private Long creatorId;

    @Column(name = "member_count", nullable = false)
    private int memberCount;

    @CreationTimestamp
    @Column(updatable = false)
    private LocalDateTime createdAt;
}
```

- Channel 검색에서 이용되는 부분은 `name` column 입니다
- `name` column에 인덱스를 설정하지 않았습니다

```java title="ChannelRepository.java"
package com.api.backend.repository;

import java.util.List;

import com.api.backend.domain.Channel;

public interface ChannelRepository extends JpaRepository<Channel, Long> {
...
    @Query(value = """
            SELECT *
            FROM channels
            WHERE REPLACE(LOWER(name), ' ', '')
                  LIKE CONCAT('%', REPLACE(LOWER(:keyword), ' ', ''), '%')
              AND (
                  :cursor IS NULL
                  OR (
                      :asc = true AND public_id > :cursor
                      OR :asc = false AND public_id < :cursor
                  )
              )
            ORDER BY
                CASE WHEN :asc = true THEN public_id END ASC,
                CASE WHEN :asc = false THEN public_id END DESC
            LIMIT :size
            """, nativeQuery = true)
    List<Channel> search(
            @Param("keyword") String keyword,
            @Param("cursor") String cursor,
            @Param("asc") boolean asc,
            @Param("size") int size);

...
}
```

- 검색 키워드와 검색 대상인 `name` column을 모두 소문자로 바꾸고, 공백을 모두 없앤 뒤, 검색 키워드 양 옆에 `%`를 붙여 부분 일치를 확인합니다
- 해당 서비스로 구성된 엔드포인트를 Jmeter를 통해 테스트하겠습니다

## JMeter 테스트

- [Jmeter 설정법](/post/8)

### 기본 테스트

- 기본 테스트는 `name` column의 인덱스를 설정하지 않고
- JPA의 쿼리에도 변경사항이 없습니다

<p style="display:flex;justify-content:center">
  <img src="../../images/9/2.png" width="100%" alt="image"/>
</p>

- Max: 응답 시간의 최대값입니다. 모든 요청이 이 시간 이내로 이루어집니다 위 차트에서 MaX의 시작값은 656ms, 끝값은 292ms입니다
- Median: 전체 요청 중 절반이 이 시간 이내로 이루어집니다 시작값은 117ms, 끝값은 105ms입니다
  - 극단적으로 느리거나 빠른 요청에 덜 영향을 받아 일반적인 체감 속도를 잘 보여줍니다
- Min: 응답 시간의 최소값입니다. 모든 요청이 이 시간 이상으로 이루어집니다 시작값은 85ms, 끝값은 62ms입니다

<p style="display:flex;justify-content:center">
  <img src="../../images/9/3.png" width="100%" alt="image"/>
</p>

- 95th percentile, 99th percentile : 전체 요청 중 95%, 99%가 이 시간 이내로 이루어집니다

  - Max 그래프와 거의 유사한 형태입니다
  - 이 그래프가 높은 값이라면, 거의 모든 요청은 빠르지만 소수의 5%,1% 요청은 느리다는 의미입니다

- 90th percentile : 상위 10%을 제외한 90%의 요청이 이 값 이하로 처리됩니다
  - 체감 품질의 상한선을 보는 데 좋습니다
  - 위 차트에서 500ms 부근에서 시작되는 그래프입니다

**왜 그래프가 우하향 하는가? (응답시간이 왜 줄어드는가)**

- 첫 요청 이후 같은 요청이나 비슷한 데이터가 오면 캐시된 DB쿼리의 결과를 이용합니다
- 인덱스가 메모리에 적재된 후 응답이 빨라지는 경우도 있습니다
- 초기에 DB 버퍼 풀에 해당 데이터 페이지가 없어 디스크를 읽는 경우 응답시간이 느려졌다가 빨라질 수 있습니다
- 파일, 페이지 캐시로 인해 응답이 빨라집니다

### 인덱스 생성

```java
package com.api.backend.domain;

import java.time.LocalDateTime;

import org.hibernate.annotations.CreationTimestamp;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "channels", indexes = {
        @Index(name = "idx_channel_name", columnList = "name")
})
@Getter
@Setter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
public class Channel {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "public_id", nullable = false, unique = true, updatable = false, length = 36)
    private String publicId;

    @Column(nullable = false)
    private String name;

    @Column(name = "creator_id", nullable = false)
    private Long creatorId;

    @Column(name = "member_count", nullable = false)
    private int memberCount;

    @CreationTimestamp
    @Column(updatable = false)
    private LocalDateTime createdAt;
}
```

- `Channel.java` Entity에 `name` colum에 대하여 인덱스를 추가하고 테스트를 시행하였습니다

<p style="display:flex;justify-content:center">
  <img src="../../images/9/4.png" width="100%" alt="image"/>
</p>

- 차트의 초반 부분이 워밍업 효과에 의해 영향을 받는다고 가정 했을때, 유의미한 후반 부분의 경우 인덱스를 적용하기 전과 큰 차이가 없었습니다

### 마무리

> 데이터베이스에서 인덱스란, 데이터 쓰기 작업에서 추가적인 쓰기 작업을 통해, 빠른 읽기 효과를 얻고자 하는 기능입니다  
> 다음 포스트에서 인덱스의 특성을 알아본 후 LIKE 검색 시 성능개선이 가능한 다른 방법을 적용하겠습니다