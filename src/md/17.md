---
filename: 17.md
tags:
  - deadlock
  - racecondition
  - os
category: cs
created: Tue, 04 Feb 2025 03:47:19 GMT
title: Race Condition, Deadlock
---

## Race Condition

- 경쟁 상태(Race Condition) 는 두 개 이상의 스레드 또는 프로세스가 동일한 공유 자원에 동시에 접근하여 예기치 않은 결과를 초래하는 문제
- 코드 실행 순서에 따라 프로그램의 동작이 달라질 가능성이 있는 상태를 의미

### 발생원인

1. 멀티스레드 또는 멀티프로세스 환경에서 공유 자원을 수정하는 경우
2. 임계 구역(Critical Section) 이 적절히 보호되지 않은 경우
3. 원자적 연산(Atomic Operation)이 아닌 연산이 수행되는 경우
4. 컨텍스트 스위치(Context Switch) 로 인해 연산 도중 다른 스레드가 실행될 경우

```c title="race condition"
#include <stdio.h>
#include <pthread.h>

int counter = 0;  // 공유 자원

void* increment(void* arg) {
    for (int i = 0; i < 1000000; i++) {
        counter++;  // 경쟁 상태 발생 가능
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;

    pthread_create(&t1, NULL, increment, NULL);
    pthread_create(&t2, NULL, increment, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    printf("Counter: %d\n", counter);  // 🔥 예상 값은 2000000, 그러나 실제 값은 다를 수 있음
    return 0;
}
```

## Deadlock

- 두 개 이상의 프로세스(또는 스레드)가 서로 자원을 점유한 상태에서, 상대방이 가진 자원을 기다리면서 무한히 블록되는 상황을 의미
- 데드락이 발생하면 어떤 프로세스도 실행을 계속할 수 없으며, 시스템은 정지 상태에 빠짐

### 발생원인

- 데드락이 발생하려면 다음 4가지 조건이 동시에 만족해야 한다
- Coffman’s Conditions (코프만의 조건)이라고도 한다

1.  상호 배제(Mutual Exclusion)
    - 하나의 자원은 한 번에 하나의 프로세스만 사용할 수 있어야 함
2.  점유 및 대기(Hold and Wait)
    - 프로세스가 이미 할당받은 자원을 점유한 상태에서, 추가 자원을 기다리는 상태
3.  비선점(No Preemption)
    - 프로세스가 점유한 자원을 강제로 빼앗을 수 없음
4.  순환 대기(Circular Wait)
    - 프로세스들 간에 순환적인 자원 대기 관계가 존재
    - 예: A 프로세스는 프린터를 점유하고 스캐너를 기다림 → B 프로세스는 스캐너를 점유하고 프린터를 기다림 → 서로 교착 상태에 빠짐

### 해결 방법

1. 예방(Prevention)

   - 발생원인 중 최소 한가지만 해결하면 Deadlock을 원천 차단 가능
     1. 상호 배제 제거 → 자원을 공유 가능하게 만듦 (ex. 읽기 전용 접근 허용)
     2. 점유 및 대기 제거 → 프로세스가 모든 자원을 한 번에 요청하도록 설계
     3. 비선점 제거 → 자원을 강제로 회수할 수 있도록 설계
     4. 순환 대기 제거 → 자원 할당 순서를 강제하여 순환 관계를 없앰

2. 회피(Avoidance)

- 은행가 알고리즘(Banker's Algorithm)
  - 안전 상태(Safe State)에서만 자원을 할당
  - 시스템이 사전에 자원의 가용성을 분석하고, 데드락이 발생할 가능성이 있으면 자원 할당을 거부
    1. A 프로세스가 5개의 메모리 블록 요청
    2. 현재 여유 메모리: 4개
    3. 데드락 발생 가능성 있음 → 요청 거부

| 용어                           | 의미                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| **Available (사용 가능 자원)** | 시스템이 현재 사용할 수 있는 자원의 개수                     |
| **Max (최대 요청 자원)**       | 각 프로세스가 최대로 필요할 수 있는 자원의 개수              |
| **Allocation (할당된 자원)**   | 현재 각 프로세스가 할당받은 자원의 개수                      |
| **Need (추가로 필요한 자원)**  | `Need = Max - Allocation` (각 프로세스가 추가로 필요한 자원) |

- 실행 과정

  1. 각 프로세스가 요청(Request)하는 자원이 `Need` 값을 초과하면 요청 거부
  2. 프로세스가 요청한 자원이 `Available` 보다 크면 요청 대기
  3. 자원 할당 후, 시스템이 "안전 상태(Safe State)"인지 확인
  4. 안전 상태라면 자원을 할당, 그렇지 않다면 요청 거부

- 시스템이 3가지 자원 **A, B, C**를 관리.
- 3개의 프로세스 **P1, P2, P3, P4, P5**가 존재.
- 현재 각 프로세스가 사용 가능한 자원(Available), 최대 필요(Max), 현재 할당된 자원(Allocation) 정보를 가짐.
- 자원 **A, B, C**의 총 값은 (10, 5, 7)

| 프로세스 | **할당된 자원 (Allocation)** | **최대 필요 자원 (Max)** | **추가 필요 자원 (Need = Max - Allocation)** |
| -------- | ---------------------------- | ------------------------ | -------------------------------------------- |
| **P1**   | (0, 1, 0)                    | (7, 5, 3)                | (7, 4, 3)                                    |
| **P2**   | (2, 0, 0)                    | (3, 2, 2)                | (1, 2, 2)                                    |
| **P3**   | (3, 0, 2)                    | (9, 0, 2)                | (6, 0, 0)                                    |
| **P4**   | (2, 1, 1)                    | (2, 2, 2)                | (0, 1, 1)                                    |
| **P5**   | (0, 0, 2)                    | (4, 3, 3)                | (4, 3, 1)                                    |

Available = (3, 3, 2)

1. 현재 Available 자원: `(3, 3, 2)`
2. P2의 Need 는 Available 자원으로 해결 가능 → 할당된 자원 (2, 0, 0)을 회수하여 Available = (5, 3, 2)
3. P4의 Need 는 Available 자원으로 해결 가능 → 할당된 자원 (2, 1, 1)을 회수하여 Available = (7, 4, 3)
4. P5의 Need 는 Available 자원으로 해결 가능 → 할당된 자원 (0, 0, 2)을 회수하여 Available = (7, 4, 5)
5. P1의 Need 는 Available 자원으로 해결 가능 → 할당된 자원 (0, 1, 0)을 회수하여 Available = (7, 5, 5)
6. P3의 Need 는 Available 자원으로 해결 가능 → 할당된 자원 (3, 0, 2)을 회수하여 Available = (10, 5, 7)
7. 안전 순서가 존재하므로 Deadlock 회피

- 안전 순서(Safe Sequence) 확인

은행가 알고리즘이 안전 상태를 검증할 때 **안전한 실행 순서(Safe Sequence)** 를 확인

- 실행 가능 프로세스의 Need가 Available보다 작아야 함
- 한 프로세스가 실행 완료 후 할당된 자원을 반환하면, 다른 프로세스가 실행 가능
- 안전한 실행 순서가 존재하면 Safe State, 없으면 Unsafe State

3. 탐지(Detection)

- 데드락이 발생했는지 주기적으로 검사하여 탐지
- 자원 할당 그래프(Resource Allocation Graph) 를 분석하여 순환 대기(Circular Wait) 관계가 존재하는지 확인

4. 복구(Recovery)

- 프로세스 종료(Kill)
  - 데드락에 관련된 프로세스를 종료하여 해결
  - 단점: 데이터 손실 발생 가능
- 자원 선점(Resource Preemption)
  - 일부 프로세스에서 자원을 회수하고 다른 프로세스에 할당
  - 단점: 프로세스가 비정상적으로 종료될 수 있음